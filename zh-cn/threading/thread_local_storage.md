### 线程局部储存(Thread-Local-Storage,TLS)  
#### 概述  
&emsp;&emsp;为了在一个线程的不同方法里使用同一个对象, 我们通常要把这个对象申明为一个静态变量或者全局变量。这样就带来一个问题, 就是对每个线程要用到这种对象的话就得都要事先申明一次线程代码还有全局或者静态变量, 这样对就显得十分的臃肿了, 或者你说以用数组呀, 但是在多线程的环境下要在一个数组里找到自己线程用的对象地址, 你几乎每次只能通过使用读写锁来安全的找到它, 这样就十分影响程序的运行效率。为此操作系统根据CPU的线程寄存器特性, 会在每个线程初始化的时候为这个线程申请一段空间并写到CPU的线程寄存器里来专门提供给这个线程使用,TLS就是这样产生的。  
#### TLS的设计  
&emsp;&emsp;TLS使用索引来寻找系统分配的线程变量, 这个索引也是事先分配的, 进程唯一的, 对当前进程的所有线程都有效的(即使这个线程还没创建)。分配索引或者销毁索引的时候是线程安全的, 但是不保证你销毁索引的时候, 还有别的线程引用了这个索引。所以你要确保其他用了这个索引的线程已经终结或者不再使用这个索引了, 操作系统还提供了线程创建销毁的回调函数, 来帮助你更好的管理这个索引。举个例子:  
```c++
#include <stdio.h>

int main(int argc, char* argv[]) {

}
```

&emsp;&emsp;Chromium对系统的TLS函数进行了封装, 并且根据TLS的机制自己实现了一套。
