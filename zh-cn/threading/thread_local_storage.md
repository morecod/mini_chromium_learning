### 线程局部储存(Thread-Local-Storage,TLS)  
#### 概述  
&emsp;&emsp;在多线程编程中, 到处都能看到TLS的影子(例如:线程命名, 线程循环, 线程内存使用统计等), 通常多个线程有共同的属性, 但是属性值由每个线程独立管理使用的时候就会用到它, 主要目的就是减少或者避免锁的使用, 想象一下所有个线程都只能在一个全局的线程命名数组里排队设置或寻找自己的名字, 效率多感人。在Windows系统下TLS的设计思想大概是这样的(其他的系统也应该差不多):  
![text](thread_local_storage.png)  
总结一下有以下几点:  
- 进程管理着所有线程属性的使用状态。
- 每个线程都有自己的私有空间。
- 所有线程都通过进程分配的索引(chromium里设计成槽对象)来获取设置对应的属性值(即使线程是在索引分配后创建的也不会受到影响)。
  
通过TLSAlloc来分配索引传递给TLSGet(Set)Value来读写属性值, 这是就是典型的空间换时间!!

#### Chromium的TLS
&emsp;&emsp;从上面的设计图可以看到线程的TLS空间范围是系统自定的, 在不同的平台下极有可能是不一致的, 这也会影响软件的跨平台稳定性, 因此Chromium基于系统的TLS(只用了一个索引)自己包装了一套应用层的TLS, 设计思想也跟上面的差不多, 只不过它把索引换成一个槽对象(里面包含了索引, 索引的使用版本,其实就是使用次数), 这样它就可以保证每个平台下的线程TLS空间是一致的。它的设计大概就下面这样的:  
![text](thread_local_storage_chromium.png)  
具体来说做了这么些事情:
- 跟进程申请了一个TLS索引来在线程里储存在它自己的TlsVerctorEntry数组地址。
- 申明了一个TlsMetadata类型的全局数组, 注册槽的时候通过它来初始化槽的索引以及版本号。
- 使用槽来设置或者获取线程变量 它先通过跟进程申请来的TLS索引来找到或者创建对应线程的TlsVerctorEntry数组, 然后再通过槽的索引来找到对应的TlsVerctorEntry并且对data进行读写, 如果槽版本跟找到的TlsVerctorEntry里的版本对不上的话就说明这个槽过期了, 操作就会不成功。
- 注册了线程销毁回调, 线程销毁的时候, 找个每个TlsVerctorEntry成员对应的TlsMetadata, 通过destructor来释放用用户数据(如果在申请这个槽的时候提供了用户数据销毁方法的话), 然后释放该线程下的TlsVerctorEntry数组。
- 在用完释放了一个槽后, 这个槽对应的TlsMetadata的使用版本将会 +1

#### 使用Chromium的TLS
&emsp;&emsp;Chromium的TLS类设计的很完美也很简单, 它给我们提供了ThreadLocalPointer, ThreadLocalBool这两种操作类。
我们只要按需申请其中一个类型的全局变量就可以在所有线程的内部使用了。看下面一个例子:  
```c++
#
``` 