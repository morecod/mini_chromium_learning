### 线程局部储存(Thread-Local-Storage,TLS)  
#### 概述  
&emsp;&emsp;在多线程编程中, 到处都能看到TLS的影子(例如:线程命名, 线程循环, 线程内存使用统计等), 通常多个线程有共同的属性, 但是属性值由每个线程独立管理使用的时候就会用到它, 主要目的就是减少或者避免锁的使用, 想象一下所有个线程都只能在一个全局的线程命名数组里排队找到自己的名字, 效率多感人。在Windows系统下TLS的设计思想大概是这样的(其他的系统也应该差不多):  
![text](thread_local_storage.png)  
总结一下有以下几点:  
- 进程管理着所有线程属性的使用状态。
- 每个线程都有自己的私有空间。
- 所有线程都通过进程分配的索引(chromium里称之槽)来获取设置对应的属性值(即使线程是在索引分配后创建的也不会受到影响)。
  
通过TLSAlloc来分配索引传递给TLSGet(Set)Value来读写属性值, 这是就是典型的空间换时间!!

#### Chromium的TLS
&emsp;&emsp;从上面的设计图可以看到线程的TLS空间范围是系统自定的, 在不同的平台下极有可能是不一致的, 这也会影响软件的跨平台稳定性, 因此Chromium基于系统的TLS(只用了一个槽)自己包装了一套应用层的TLS, 设计思想也跟上面的差不多, 这样它就可以保证每个平台下的线程TLS空间是一致的。它的设计大概就下面这样的:  
![text](thread_local_storage_chromium.png)  
具体来说做了这么些事情:
- 跟进程申请了一个TLS槽用来在线程里储存在它自己的TlsVerctorEntry数组地址。
- 申明了一个TlsMetadata类型的全局数组, 来对TlsVerctorEntry的数组索引进行分配管理。
- 设置或者获取线程变量的时候, 它先通过跟进程申请来的TLS槽来找到对应线程的TlsVerctorEntry数组, 然后再通过它自己分配的索引来找到对应的TlsVerctorEntry对data进行读写。
- 注册了进程的线程销毁回调, 线程销毁的时候, 找个每个TlsVerctorEntry成员对应的TlsMetadata, 通过destructor来释放用数据(如果在申请这个槽的时候提供了销毁方法的话)。